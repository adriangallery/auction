<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>$ADRIAN Auction</title>
  <!-- Cargamos ethers.js vía UMD -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
</head>
<body>
  <h1>$ADRIAN Auction</h1>
  
  <!-- Conectar MetaMask -->
  <button id="connectButton">Connect MetaMask</button>
  <p id="accountDisplay"></p>
  
  <h2>Time Remaining</h2>
  <p id="timeRemainingDisplay">Loading...</p>
  
  <h2>Current Highest Bid</h2>
  <p>
    The highest bid so far is: <span id="highestBidDisplay">0</span> ADRIAN
  </p>
  
  <!-- Sección Top 10 -->
  <h2>Top 10 Bidders</h2>
  <div id="top10Display">Loading top 10...</div>
  
  <!-- Sección Auction Stats -->
  <h2>Auction Stats</h2>
  <div id="auctionStatsDisplay">Loading auction stats...</div>
  
  <!-- Place a Bid -->
  <h2>Place a Bid</h2>
  <p>Enter the amount of ADRIAN you want to bid:</p>
  <input type="number" id="amountInput" placeholder="Amount of ADRIAN">
  <br>
  <!-- Botones para aprobar y depositar tokens -->
  <button id="approveButton">Approve ADRIAN</button>
  <button id="depositButton">Deposit Tokens</button>
  
  <!-- Sección Admin Controls -->
  <h2>Admin Controls</h2>
  <button id="pauseButton">Pause Auction</button>
  <button id="unpauseButton">Unpause Auction</button>
  <br><br>
  <input type="number" id="resetDurationInput" placeholder="New duration (in seconds)">
  <button id="resetButton">Reset Auction</button>
  
  <script>
    // Actualiza las direcciones según corresponda:
    // Contrato de subasta: 0x34c9b2a524f882b754feab9a09f06fb64f5d73ed
    // Token ADRIAN: 0x7E99075Ce287F1cF8cBCAaa6A1C7894e404fD7Ea
    const auctionAddress = "0x34c9b2a524f882b754feab9a09f06fb64f5d73ed";
    const auctionABI = [
      "function depositTokens(uint256 amount) external",
      "function highestBid() view returns (uint256)",
      "function highestBidder() view returns (address)",
      "function auctionEndTime() view returns (uint256)",
      "function getTop10Bidders() view returns (address[] memory, uint256[] memory)",
      "function getBidderPosition(address bidder) view returns (uint256, uint256)",
      "function getAuctionStats() view returns (uint256, address, uint256, uint256, uint256)",
      "function pauseAuction() external",
      "function unpauseAuction() external",
      "function resetAuction(uint256 newDuration) external",
      "event TokensDeposited(address indexed bidder, uint256 amount)"
    ];
    
    // Token ADRIAN (contract name: ADRIANToken)
    const tokenAddress = "0x7E99075Ce287F1cF8cBCAaa6A1C7894e404fD7Ea";
    const tokenABI = [
      "function approve(address spender, uint256 amount) external returns (bool)",
      "function allowance(address owner, address spender) view returns (uint256)",
      "function balanceOf(address account) view returns (uint256)"
    ];
    
    let provider, signer, auctionContract, tokenContract;
    
    // Conectar MetaMask
    async function connectWallet() {
      if (window.ethereum) {
        provider = new ethers.providers.Web3Provider(window.ethereum);
        try {
          await provider.send("eth_requestAccounts", []);
          signer = provider.getSigner();
          const account = await signer.getAddress();
          document.getElementById("accountDisplay").innerText = "Connected account: " + account;
          
          auctionContract = new ethers.Contract(auctionAddress, auctionABI, signer);
          tokenContract = new ethers.Contract(tokenAddress, tokenABI, signer);
          
          updateHighestBid();
          updateTimeRemaining();
          updateTop10();
          updateAuctionStats();
          
          // Intervalos de actualización
          setInterval(updateTimeRemaining, 5000);
          setInterval(updateTop10, 10000);
          setInterval(updateAuctionStats, 15000);
        } catch (error) {
          console.error("Error connecting to MetaMask:", error);
          alert("Error connecting to MetaMask. See console for details.");
        }
      } else {
        alert("MetaMask is not installed");
      }
    }
    document.getElementById("connectButton").addEventListener("click", connectWallet);
    
    // Actualiza la puja más alta
    async function updateHighestBid() {
      try {
        const highestBidRaw = await auctionContract.highestBid();
        document.getElementById("highestBidDisplay").innerText = ethers.utils.formatUnits(highestBidRaw, 18);
      } catch (error) {
        console.error("Error fetching highest bid:", error);
      }
    }
    
    // Actualiza el tiempo restante de la subasta
    async function updateTimeRemaining() {
      try {
        const auctionEndTimeRaw = await auctionContract.auctionEndTime();
        const endTime = parseInt(auctionEndTimeRaw.toString());
        const now = Math.floor(Date.now() / 1000);
        let secondsRemaining = endTime - now;
        if (secondsRemaining < 0) secondsRemaining = 0;
        const hours = Math.floor(secondsRemaining / 3600);
        const minutes = Math.floor((secondsRemaining % 3600) / 60);
        const seconds = secondsRemaining % 60;
        document.getElementById("timeRemainingDisplay").innerText =
          hours + "h " + minutes + "m " + seconds + "s";
      } catch (error) {
        console.error("Error updating time remaining:", error);
        document.getElementById("timeRemainingDisplay").innerText = "Error fetching time.";
      }
    }
    
    // Actualiza el top 10 de pujadores
    async function updateTop10() {
      try {
        const [topBidders, topBids] = await auctionContract.getTop10Bidders();
        let html = "";
        for (let i = 0; i < topBidders.length; i++) {
          const truncated = topBidders[i].slice(-4);
          const bidAmount = ethers.utils.formatUnits(topBids[i], 18);
          html += `<p>${i + 1}. 0x...${truncated} - ${bidAmount} ADRIAN</p>`;
        }
        document.getElementById("top10Display").innerHTML = html;
      } catch (error) {
        console.error("Error updating top 10:", error);
        document.getElementById("top10Display").innerText = "Error loading top 10.";
      }
    }
    
    // Actualiza las estadísticas generales de la subasta
    async function updateAuctionStats() {
      try {
        const [highestBid, highestBidder, totalTokens, bidderCount, endTime] = await auctionContract.getAuctionStats();
        let statsHtml = `<p>Highest Bid: ${ethers.utils.formatUnits(highestBid, 18)} ADRIAN</p>`;
        statsHtml += `<p>Highest Bidder: ${highestBidder}</p>`;
        statsHtml += `<p>Total Tokens: ${ethers.utils.formatUnits(totalTokens, 18)} ADRIAN</p>`;
        statsHtml += `<p>Number of Bidders: ${bidderCount}</p>`;
        const endDate = new Date(endTime.toNumber() * 1000);
        statsHtml += `<p>Auction Ends At: ${endDate.toLocaleString()}</p>`;
        document.getElementById("auctionStatsDisplay").innerHTML = statsHtml;
      } catch (error) {
        console.error("Error fetching auction stats:", error);
        document.getElementById("auctionStatsDisplay").innerText = "Error loading auction stats.";
      }
    }
    
    // Obtiene la posición del pujador
    async function updateMyPosition() {
      if (!userAccount) {
        document.getElementById("myPositionDisplay").innerText = "Not connected";
        return;
      }
      try {
        const [position, bidAmount] = await auctionContract.getBidderPosition(userAccount);
        document.getElementById("myPositionDisplay").innerText =
          `Your Position: ${position} - Your Bid: ${ethers.utils.formatUnits(bidAmount, 18)} ADRIAN`;
      } catch (error) {
        console.error("Error fetching your position:", error);
        document.getElementById("myPositionDisplay").innerText = "Error loading your position.";
      }
    }
    // (Si tienes un botón para posición, agrega listener)
    
    // Función para aprobar tokens (approve)
    async function approveTokens() {
      const amountInput = document.getElementById("amountInput").value;
      if (!amountInput || amountInput <= 0) {
        alert("Please enter a valid amount");
        return;
      }
      const amount = ethers.utils.parseUnits(amountInput, 18);
      try {
        const tx = await tokenContract.approve(auctionAddress, amount);
        alert("Approval transaction sent. Wait for confirmation.");
        await tx.wait();
        alert("Approval confirmed");
      } catch (error) {
        console.error("Error during approval:", error);
        alert("Error during approval. See console for details.");
      }
    }
    document.getElementById("approveButton").addEventListener("click", approveTokens);
    
    // Función para depositar tokens (requiere aprobación previa)
    async function depositTokens() {
      const amountInput = document.getElementById("amountInput").value;
      if (!amountInput || amountInput <= 0) {
        alert("Please enter a valid amount");
        return;
      }
      const amount = ethers.utils.parseUnits(amountInput, 18);
      try {
        // Verifica que la aprobación sea suficiente
        const allowance = await tokenContract.allowance(userAccount, auctionAddress);
        if (allowance.lt(amount)) {
          alert("Allowance insufficient. Please approve first.");
          return;
        }
        const tx = await auctionContract.depositTokens(amount);
        alert("Deposit transaction sent. Wait for confirmation.");
        await tx.wait();
        alert("Deposit confirmed");
        updateHighestBid();
        updateTop10();
        updateAuctionStats();
      } catch (error) {
        console.error("Error depositing tokens:", error);
        alert("Error depositing tokens. See console for details.");
      }
    }
    document.getElementById("depositButton").addEventListener("click", depositTokens);
    
    // Funciones Admin: Pausar, unpause y reset
    async function pauseAuction() {
      try {
        const tx = await auctionContract.pauseAuction();
        alert("Pause transaction sent. Wait for confirmation.");
        await tx.wait();
        alert("Auction paused");
      } catch (error) {
        console.error("Error pausing auction:", error);
        alert("Error pausing auction");
      }
    }
    document.getElementById("pauseButton").addEventListener("click", pauseAuction);
    
    async function unpauseAuction() {
      try {
        const tx = await auctionContract.unpauseAuction();
        alert("Unpause transaction sent. Wait for confirmation.");
        await tx.wait();
        alert("Auction unpaused");
      } catch (error) {
        console.error("Error unpausing auction:", error);
        alert("Error unpausing auction");
      }
    }
    document.getElementById("unpauseButton").addEventListener("click", unpauseAuction);
    
    async function resetAuction() {
      const durationInput = document.getElementById("resetDurationInput").value;
      if (!durationInput || durationInput <= 0) {
        alert("Please enter a valid duration (in seconds)");
        return;
      }
      try {
        const tx = await auctionContract.resetAuction(durationInput);
        alert("Reset transaction sent. Wait for confirmation.");
        await tx.wait();
        alert("Auction reset");
        updateHighestBid();
        updateTimeRemaining();
        updateTop10();
        updateAuctionStats();
      } catch (error) {
        console.error("Error resetting auction:", error);
        alert("Error resetting auction");
      }
    }
    document.getElementById("resetButton").addEventListener("click", resetAuction);
    
  </script>
</body>
</html>
